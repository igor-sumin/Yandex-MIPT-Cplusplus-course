#include <bits/stdc++.h>
using namespace std;

template <typename T>
T Max(T a, T b) {
	// при использовании тернарного оператора компилятор в некоторых случаях отказывает в доступе
	// return (a < b) & b : a;

	if(a < b) {
		return b;
	}

	return a;
}

// Выведение шаблонного типа
int main() {
	cout << Max(2, 3) << endl;	// 3

	// Два варианта событий, когда компилятор не знает что делать с типом T: (мы используем 2 вариант)
	// 1. Явно приводим к одному из типов
	// 2. Подсказываем компилятору какой тип используется вместо типа T
	cout << Max<double>(2, 3.5) << endl; // 3.5

	// В таком случае компилятор приводит ответ к int
	cout << Max<int>(4, 13.8) << endl; 	 // 13

	// Также данные конструкции работают и со встроенными библиотеками и их методами
	// Явное указание типа при вызове функции
	cout << max<int>(4, 13.1) << endl;	 // 13

	return 0;
}