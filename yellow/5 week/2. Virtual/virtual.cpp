#include <bits/stdc++.h>
// Подключение shared_ptr
#include <memory>

using namespace std;

// В языке C++ из базового класса мы никаким образом не можем добраться до приватных полей классов-потомков, 
// иначе бы это нарушало инкапсуляцию, то есть сокрытие данных и деталей внутренней реализации
class Animal {
public:
	Animal(const string& t) : type(t) {}

	void Eat(const string& fruit) {
		cout << type << " eats " << fruit << endl;
	}

	// 1. Как же нам сделать так, чтобы базовый класс узнал про методы в классах потомках. 
	// Сделать мы можем это следующим образом: добавим ключевое слово "virtual" к методу в базовом классе

	// 2. С помощью ключевого слова "virtual" мы говорим базовому классу о том, что в классах потомках, 
	// которые от него унаследованы, может быть реализация метода Voice с точно такой же сигнатурой 

	// 3. Когда мы вызываем этот метод у базового класса, на самом деле будет вызываться метод у класса потомка

	// 4. Мы избавились от смешения кода в рамках базового класса, разнесли код по классам потомкам и при этом 
	// можем удобно в рамках одной функции MakeSound, зная только базовый класс, вызывать различные специализации у классов потомков.

	// 5. В классах-потомках, если такой метод не объявлен, то он будет вызван из базового класса.
	virtual void Voice() const {
		cout << type << " is silent" << endl;
	}

	// 1. Можно потребовать от всех классов-потомков обязательной реализации данного метода

	// 2. Данный синтаксис говорит компилятору о том, что виртуальный метод Voice является абстрактным или чисто виртуальным. 
	// Это означает, что мы теперь требуем в каждом классе-потомке его обязательной реализации.

	// 3. Синтаксис абстрактных виртуальных методов, мы можем добиться того, 
	// что для каждого такого виртуального метода в классах-потомках у нас будет обязательно требоваться реализация.
	virtual void Voice() const = 0;

private:
	const string type;
};

// С помощью публичного наследования мы получили доступ к методам и полям класса animal.
class Cat : public Animal {
public:
	Cat() : Animal("cat") {}

	// 1. В классах потомках в метод Voice добавим ключевое слово — "override"

	// 2. Если мы в базовом классе захотим изменить название метода, 
	// то компилятор нам подскажет и выдаст ошибку о том, что больше в базовом классе метод Voice неизвестен.

	// 3. Требует объявления метода в базовом классе с такой же сигнатурой
	void Voice() const override {
		cout << "meow!" << endl;
	}
};

class Dog : public Animal {
public:
	Dog() : Animal("dog") {}

	void Voice() const override {
		cout << "whaf!" << endl;
	}
};

class Parrot : public Animal {
public:
	// Нужно вызвать конструктор базового класса
	Parrot(const string& _name) : Animal("Parrot"), name(_name) {}

	void Voice() const override {
		cout << name << " is good!" << endl;
	}

private:
	const string name;
	// const string& name;
};

// У класса Horse нет реализации абстрактного метода Voice, таким образом класс Horse считается абстрактным. 
class Horse : public Animal {
public:
	// Абстрактными типами, в данном случае классами называются те классы, у которых есть абстрактные методы, и для них нет реализации.
	Horse() : Animal("Horse") {}
};

// 1. (!) При передаче параметра по значению мы теряем всю информацию об объекте класса-потомка, 
// и у нас сохраняется информация только об объекте базового класса

// 2. Если мы внезапно решим передавать объекты не по ссылке, а по значению, то мы потеряем преимущество виртуальных методов и не сможем ими воспользоваться. 
// Поэтому по возможности нужно всегда передавать объекты именно по ссылке, а не по значению.
void MakeSound(const Animal& a) {
	a.Voice();
}

int main() {
	Cat c;
	Dog d;
	Parrot p("Gosha");

	MakeSound(c);
	MakeSound(p);
	MakeSound(d);
	
	// ...

	// 1. Объединим наши различные объекты разных классов

	// 2. Первое и самое полезное свойство, которое нам поможет решить нашу задачу — это то, что мы в качестве типом объекта, 
	// который оборачивается в shared_ptr можем указать просто animal, не ссылку на него. И при этом shared_ptr будет вести себя как ссылка. 
	// То есть мы сможем в него положить объекты производных классов и безболезненно обращаться к интерфейсу базового класса. 

	// 3. Второе полезное свойство — что объекты типа shared_ptr имеют очень похожий интерфейс на итератора.

	// 4. Давайте посмотрим, как же, во-первых, мы можем обернуть какой-то объект типа Cat, Dog или Parrot в наш shared_ptr.
	shared_ptr<Animal> a;

	// У метода make_shared в угловых скобках необходимо указать реальный тип объекта, который мы хотим создать.
	a = make_shared<Cat>();
	// Для вызова метода Voice мы записываем название объекта, затем мы указываем стрелочку на нужный нам метод
	a->Voice();		// meow!


	// Теперь объединим различные объекты разных классов животных
	// Давайте попробуем его инициализировать различными объектами
	vector<shared_ptr<Animal>> animals = {
		make_shared<Cat>(),
		make_shared<Dog>(),
		// В качестве аргументов функция make_shared как раз принимает тот набор объектов, 
		// значений, строк, чисел, которые она затем передает в конструктор этого объекта.
		make_shared<Parrot>("Kesha")
	};

	// С помощью shared_ptr мы можем помещать различные типа объектов производных классов в контейнеры 
	// и обходить их с помощью циклом так же, как и обычные типы
	for(auto a : animals) {
		// Мы должны разыменовать объект типа shared_ptr, чтобы получить тот объект, который в нем обернут
		MakeSound(*a);
	}

	return 0;
}
